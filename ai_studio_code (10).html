<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>浩瀚无垠 - 星际指挥舱</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; background: radial-gradient(circle at center, #08080a 0%, #000000 100%); }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* 玻璃拟态基础 */
        .glass {
            background: rgba(12, 12, 14, 0.75); 
            backdrop-filter: blur(16px); 
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(197, 160, 89, 0.25);
            box-shadow: 0 8px 32px rgba(0,0,0,0.9);
            color: #ddd;
            pointer-events: auto;
            transition: all 0.5s cubic-bezier(0.23, 1, 0.32, 1);
        }

        /* 顶部大标题 */
        #main-title {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: none; z-index: 5;
            mix-blend-mode: screen; 
        }
        .title-text {
            font-size: 32px; font-weight: 300; letter-spacing: 15px; margin-bottom: 8px; white-space: nowrap;
            background: linear-gradient(180deg, #fff 0%, #e0cda7 60%, #c5a059 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(197, 160, 89, 0.3); opacity: 0.9;
        }
        .title-sub { font-size: 10px; color: #666; letter-spacing: 6px; font-family: 'Segoe UI', sans-serif; text-transform: uppercase; opacity: 0.7; }

        /* 左上角信息 */
        #info-panel {
            position: absolute; top: 30px; left: 30px; padding: 12px 20px;
            border-left: 3px solid #c5a059; border-radius: 0 4px 4px 0;
        }
        h1 { margin: 0; font-weight: 400; color: #e0cda7; letter-spacing: 2px; font-size: 14px; opacity: 0.8; }
        .fps-text { font-family: monospace; font-size: 12px; color: #888; margin-top: 4px; }

        /* 左下角手势开关 */
        #gesture-control-dock {
            position: absolute; bottom: 30px; left: 30px;
            padding: 10px 20px; border-radius: 30px;
            display: flex; align-items: center; gap: 15px;
            border: 1px solid rgba(197, 160, 89, 0.3);
        }
        .gesture-label { font-size: 14px; color: #e0cda7; font-weight: bold; letter-spacing: 1px; }

        .toggle-switch { position: relative; width: 44px; height: 24px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #444; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #c5a059; }
        input:checked + .slider:before { transform: translateX(20px); }

        /* 右侧控制面板 */
        #control-panel {
            position: absolute; top: 30px; right: 0; width: 260px;
            height: auto; padding: 25px;
            border-radius: 4px 0 0 4px; border-right: none; border-left: 2px solid #c5a059;
            transform: translateX(100%); opacity: 0;
        }
        #control-panel.active { transform: translateX(0); opacity: 1; }

        #panel-toggle-btn {
            position: absolute; top: 120px; right: 0; 
            width: 36px; height: 60px; cursor: pointer; z-index: 20; pointer-events: auto;
            background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(8px);
            border: 1px solid rgba(197, 160, 89, 0.3); border-right: none; border-radius: 8px 0 0 8px;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.5s cubic-bezier(0.23, 1, 0.32, 1);
        }
        #panel-toggle-btn:hover { background: rgba(197, 160, 89, 0.15); box-shadow: 0 0 15px rgba(197,160,89,0.2); }
        #control-panel.active + #panel-toggle-btn { right: 310px; }
        .toggle-icon {
            width: 0; height: 0; border-top: 6px solid transparent; border-bottom: 6px solid transparent;
            border-right: 8px solid #c5a059; transition: transform 0.4s;
        }
        #control-panel.active + #panel-toggle-btn .toggle-icon { transform: rotate(180deg); }

        /* 底部导航栏 */
        #bottom-dock {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; padding: 12px 25px; border-radius: 50px;
            border: 1px solid rgba(197, 160, 89, 0.2);
            background: rgba(10, 10, 12, 0.6); backdrop-filter: blur(12px);
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); z-index: 50; pointer-events: auto;
        }
        .nav-link {
            text-decoration: none; color: #ccc; font-family: 'Segoe UI', sans-serif; font-size: 13px; font-weight: 500;
            letter-spacing: 1px; padding: 8px 24px; border: 1px solid rgba(255,255,255,0.1); border-radius: 20px;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); position: relative; overflow: hidden;
            display: flex; align-items: center; background: rgba(0,0,0,0.2);
        }
        .nav-link:hover {
            color: #111; background: #c5a059; border-color: #c5a059;
            box-shadow: 0 0 20px rgba(197, 160, 89, 0.4); transform: translateY(-2px);
        }
        .nav-link::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent); transition: 0.5s;
        }
        .nav-link:hover::before { left: 100%; }

        /* 控件通用 */
        h2 { margin: 0 0 15px; font-weight: 400; color: #c5a059; font-size: 13px; letter-spacing: 1px; border-bottom: 1px solid rgba(197,160,89,0.2); padding-bottom: 5px; }
        .control-group { margin-bottom: 18px; }
        .control-label { display: flex; justify-content: space-between; font-size: 12px; color: #aaa; margin-bottom: 6px; }
        .control-value { color: #c5a059; font-family: monospace; }
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; margin: 0; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 3px; cursor: pointer; background: rgba(255,255,255,0.15); }
        input[type=range]::-webkit-slider-thumb { height: 12px; width: 12px; border-radius: 50%; background: #c5a059; cursor: pointer; -webkit-appearance: none; margin-top: -4.5px; box-shadow: 0 0 8px rgba(197,160,89,0.6); }

        .disabled-control { opacity: 0.4; pointer-events: none; filter: grayscale(100%); }
        .manual-active-indicator { color: #88aaee; font-size: 11px; margin-left: 5px; opacity: 0; transition: opacity 0.3s; }
        .show-indicator { opacity: 1; }

        /* 加载提示设为隐藏 */
        #loading { display: none; }
        .input_video { display: none; }
    </style>
</head>
<body>

    <video class="input_video"></video>
    <div id="loading"></div>

    <div id="ui-layer">
        
        <!-- 顶部居中大标题 -->
        <div id="main-title">
            <div class="title-text">浩瀚无垠 志存高远</div>
            <div class="title-sub">VAST BOUNDLESS · AIM HIGH</div>
        </div>

        <div id="info-panel" class="glass">
            <h1>土星监测站</h1>
            <div class="fps-text">帧率: <span id="ui-fps">--</span> | 粒子: <span id="ui-particles">--</span></div>
            <div class="fps-text" id="status-text">手动控制模式</div>
        </div>

        <div id="gesture-control-dock" class="glass">
            <span class="gesture-label">手势控制</span>
            <label class="toggle-switch">
                <input type="checkbox" id="chk-gesture">
                <span class="slider"></span>
            </label>
        </div>

        <!-- 底部导航栏 -->
        <div id="bottom-dock">
            <a href="https://adam.greetgic.top" target="_blank" class="nav-link">PROFILE</a>
            <a href="https://blog.greetgic.top" target="_blank" class="nav-link">BLOG</a>
            <a href="http://8.162.7.105/listen/app/" target="_blank" class="nav-link">MUSIC</a>
        </div>

        <div id="control-panel" class="glass">
            <h2>形态控制 <span id="manual-ind" class="manual-active-indicator">● 手动接管</span></h2>
            
            <div id="manual-group">
                <div class="control-group">
                    <!-- 默认缩放改为 2.13 -->
                    <div class="control-label"><span>缩放 (Scale)</span><span id="val-m-scale" class="control-value">2.13</span></div>
                    <input type="range" id="inp-m-scale" min="0.2" max="3.5" step="0.01" value="2.13">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>俯仰 (Pitch)</span><span id="val-m-rot" class="control-value">-0.10</span></div>
                    <input type="range" id="inp-m-rot" min="-1.0" max="1.0" step="0.01" value="-0.10">
                </div>
            </div>
            
            <div class="control-group">
                <!-- 自转速度调整间隔改为 0.05 -->
                <div class="control-label"><span>自转速度 (Speed)</span><span id="val-speed" class="control-value">0.1</span></div>
                <input type="range" id="inp-speed" min="0.0" max="2.0" step="0.05" value="0.1">
            </div>

            <div style="height:10px;"></div>

            <h2>渲染参数</h2>
            <div class="control-group">
                <div class="control-label"><span>亮度 (Exposure)</span><span id="val-bright" class="control-value">1.9</span></div>
                <input type="range" id="inp-bright" min="0.5" max="3.0" step="0.1" value="1.9">
            </div>

            <div class="control-group">
                <div class="control-label"><span>粒子密度 (Density)</span><span id="val-lod" class="control-value">100%</span></div>
                <input type="range" id="inp-lod" min="0.0" max="1.0" step="0.05" value="1.0">
            </div>

            <div class="control-group disabled-control" id="sens-group">
                <div class="control-label"><span>手势灵敏度</span><span id="val-sens" class="control-value">1.0</span></div>
                <input type="range" id="inp-sens" min="0.5" max="2.5" step="0.1" value="1.0">
            </div>
            
            <div style="margin-top:20px; text-align:center;">
                <button onclick="toggleFullScreen()" style="background:rgba(197,160,89,0.1); border:1px solid #c5a059; color:#c5a059; padding:6px 15px; cursor:pointer; font-size:12px;">进入全屏模式</button>
            </div>
        </div>
        
        <div id="panel-toggle-btn" onclick="togglePanel()">
            <div class="toggle-icon"></div>
        </div>

    </div>

    <div id="canvas-container"></div>

    <script>
        // ================= 配置 =================
        const CONFIG = { baseParticleCount: 350000 };
        let STATE = {
            isGestureMode: false,
            sensitivity: 1.0,
            manualScale: 2.13, // 默认缩放设为 2.13
            manualRotX: -0.10,
            ringSpeed: 0.1
        };

        // ================= SHADERS =================
        
        // 1. 土星 (粒子)
        const SATURN_VS = `
            attribute float size; attribute vec3 customColor; attribute float opacityAttr;
            attribute float orbitSpeed; attribute float isRing; attribute float aRandomId;
            varying vec3 vColor; varying float vDist; varying float vOpacity; varying float vScaleFactor;
            uniform float uTime; uniform float uScale; uniform float uRotationX; uniform float uLODLevel; uniform float uSpeedFactor;
            mat2 rotate2d(float a){ return mat2(cos(a),-sin(a), sin(a),cos(a)); }
            void main() {
                float distFactor = smoothstep(0.1, 2.5, uScale); 
                float threshold = (1.0 - (1.0 - distFactor) * 0.5) * uLODLevel; 
                if (aRandomId > threshold) { gl_Position = vec4(0.0); return; }
                vec3 pos = position;
                if (isRing > 0.5) pos.xz = rotate2d(uTime * orbitSpeed * uSpeedFactor) * pos.xz;
                else pos.xz = rotate2d(uTime * 0.03) * pos.xz;
                float cx = cos(uRotationX), sx = sin(uRotationX);
                pos.yz = mat2(cx, -sx, sx, cx) * pos.yz;
                vec4 mvPos = modelViewMatrix * vec4(pos * uScale, 1.0);
                vDist = -mvPos.z;
                if (vDist < 25.0) mvPos.x += sin(uTime * 15.0 + pos.y) * 0.1 * (1.0 - vDist/25.0);
                gl_Position = projectionMatrix * mvPos;
                float pSize = size * (280.0 / vDist); 
                if (isRing < 0.5 && vDist < 50.0) pSize *= 0.8;
                gl_PointSize = clamp(pSize, 0.0, 300.0);
                vColor = customColor; vOpacity = opacityAttr; vScaleFactor = uScale;
            }
        `;
        const SATURN_FS = `
            varying vec3 vColor; varying float vDist; varying float vOpacity; varying float vScaleFactor;
            uniform float uBrightness;
            void main() {
                vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                float rSq = dot(cxy, cxy);
                float shape = exp(-rSq * 4.0);
                float t = clamp((vScaleFactor - 0.15) / 2.35, 0.0, 1.0);
                vec3 darkBase = vec3(0.25, 0.15, 0.05); 
                vec3 col = mix(darkBase, vColor, smoothstep(0.0, 0.9, t));
                float brightFactor = 0.5 * uBrightness; 
                if(vDist < 40.0) brightFactor *= 1.3;
                gl_FragColor = vec4(col * brightFactor, shape * vOpacity * (0.2 + 0.5 * t));
            }
        `;

        // 2. 星星
        const STAR_VS = `attribute float s; attribute vec3 c; varying vec3 vC; void main(){vC=c; vec4 p=modelViewMatrix*vec4(position,1.); gl_PointSize=s*(600./-p.z); gl_Position=projectionMatrix*p;}`;
        const STAR_FS = `varying vec3 vC; void main(){vec2 p=2.*gl_PointCoord-1.; float a=exp(-dot(p,p)*4.); gl_FragColor=vec4(vC,a*0.8);}`;

        // 3. 通用行星顶点
        const PLANET_VS = `
            varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPosition;
            void main() {
                vUv = uv; vNormal = normalize(normalMatrix * normal);
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vViewPosition = -mvPosition.xyz; gl_Position = projectionMatrix * mvPosition;
            }
        `;

        // 4. 地球 (Earth)
        const EARTH_FS = `
            uniform float uTime; varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPosition;
            float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
            float noise(vec2 p) {
                vec2 i = floor(p); vec2 f = fract(p); f = f*f*(3.0-2.0*f);
                return mix(mix(hash(i + vec2(0.0,0.0)), hash(i + vec2(1.0,0.0)), f.x),
                           mix(hash(i + vec2(0.0,1.0)), hash(i + vec2(1.0,1.0)), f.x), f.y);
            }
            float fbm(vec2 p) { float v=0.; float a=0.5; for(int i=0;i<5;i++){v+=a*noise(p);p*=2.;a*=0.5;} return v; }
            void main() {
                float n = fbm(vUv * 4.0);
                float isLand = smoothstep(0.48, 0.50, n);
                vec3 waterDeep = vec3(0.0, 0.1, 0.3); vec3 waterShallow = vec3(0.0, 0.3, 0.6);
                vec3 landGreen = vec3(0.1, 0.35, 0.1); vec3 landBrown = vec3(0.3, 0.25, 0.15);
                vec3 oceanColor = mix(waterDeep, waterShallow, fbm(vUv * 6.0 + uTime*0.05));
                vec3 landColor = mix(landGreen, landBrown, fbm(vUv * 8.0));
                vec3 baseColor = mix(oceanColor, landColor, isLand);
                float clouds = fbm(vUv * 6.0 + vec2(uTime * 0.02, 0.0));
                clouds = smoothstep(0.45, 0.8, clouds);
                baseColor = mix(baseColor, vec3(1.0), clouds * 0.9);
                vec3 normal = normalize(vNormal); vec3 viewDir = normalize(vViewPosition);
                float fresnel = pow(1.0 - dot(viewDir, normal), 3.0);
                vec3 atmosphere = vec3(0.4, 0.6, 1.0) * fresnel;
                vec3 lightDir = normalize(vec3(1.0, 0.5, 1.0));
                float diff = max(dot(normal, lightDir), 0.05);
                gl_FragColor = vec4(baseColor * diff + atmosphere, 1.0);
            }
        `;

        // 5. 火星 (Mars)
        const MARS_FS = `
            uniform float uTime; varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPosition;
            float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
            float noise(vec2 p) {
                vec2 i = floor(p); vec2 f = fract(p); f = f*f*(3.0-2.0*f);
                return mix(mix(hash(i + vec2(0.0,0.0)), hash(i + vec2(1.0,0.0)), f.x),
                           mix(hash(i + vec2(0.0,1.0)), hash(i + vec2(1.0,1.0)), f.x), f.y);
            }
            float fbm(vec2 p) { float v=0.; float a=0.5; for(int i=0;i<6;i++){v+=a*noise(p);p*=2.05;a*=0.48;} return v; }
            void main(){
                float detail = fbm(vUv * 8.0);
                float macro = fbm(vUv * 2.0);
                vec3 rust = vec3(0.65, 0.25, 0.1);    
                vec3 dark = vec3(0.3, 0.1, 0.05);     
                vec3 dust = vec3(0.8, 0.45, 0.25);    
                vec3 col = mix(dark, rust, smoothstep(0.3, 0.7, detail));
                col = mix(col, dust, smoothstep(0.6, 1.0, macro * detail));
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(vec3(1.0, 0.5, 1.0));
                float diff = max(dot(normal, lightDir), 0.1);
                vec3 viewDir = normalize(vViewPosition);
                float fresnel = pow(1.0 - dot(viewDir, normal), 4.0);
                vec3 atmosphere = vec3(0.9, 0.4, 0.1) * fresnel * 0.8;
                gl_FragColor = vec4(col * diff + atmosphere, 1.0);
            }
        `;

        // ================= 引擎逻辑 =================
        let scene, camera, renderer, particles, stars, planetGroup, uniforms, earthUniforms;
        let targetScale = STATE.manualScale; 
        let targetRotX = STATE.manualRotX;
        let isHandDetected = false;
        let stats = { frameCount: 0, lastCheck: 0 };

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.00015);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.z = 100;
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            container.appendChild(renderer.domElement);

            buildSaturn();
            buildStars();
            buildPlanets();
            setupControls();
            updateControlState();

            requestAnimationFrame(gameLoop);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function buildSaturn() {
            const count = CONFIG.baseParticleCount;
            const geo = new THREE.BufferGeometry();
            const pos = [], col = [], size = [], op = [], spd = [], ring = [], rid = [];
            
            const cBody = [new THREE.Color('#4A3228'), new THREE.Color('#382820')];
            const cRing = [new THREE.Color('#0F0C08'), new THREE.Color('#3A2F26'), new THREE.Color('#222222')];

            for(let i=0; i<count; i++) {
                rid.push(Math.random());
                const isR = i > count * 0.22;
                ring.push(isR ? 1 : 0);
                if(!isR) {
                    const theta = Math.random()*6.28, phi = Math.acos(2*Math.random()-1), r = 18;
                    pos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.cos(phi)*0.9, r*Math.sin(phi)*Math.sin(theta));
                    const c = cBody[Math.floor(Math.random()*2)]; col.push(c.r, c.g, c.b);
                    size.push(1.5 + Math.random()); op.push(0.6); spd.push(0);
                } else {
                    const rBase = 22 + Math.random() * 20, theta = Math.random()*6.28;
                    pos.push(rBase*Math.cos(theta), (Math.random()-0.5)*0.25, rBase*Math.sin(theta));
                    let cIndex = rBase<27?0:rBase>36?2:1; const c = cRing[cIndex];
                    col.push(c.r, c.g, c.b); size.push(0.6 + Math.random()); op.push(0.5); spd.push(8.0/Math.sqrt(rBase));
                }
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('customColor', new THREE.Float32BufferAttribute(col, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(size, 1));
            geo.setAttribute('opacityAttr', new THREE.Float32BufferAttribute(op, 1));
            geo.setAttribute('orbitSpeed', new THREE.Float32BufferAttribute(spd, 1));
            geo.setAttribute('isRing', new THREE.Float32BufferAttribute(ring, 1));
            geo.setAttribute('aRandomId', new THREE.Float32BufferAttribute(rid, 1));

            uniforms = { 
                uTime: { value: 0 }, 
                uScale: { value: STATE.manualScale },
                uRotationX: { value: STATE.manualRotX },
                uLODLevel: { value: 1.0 }, 
                uBrightness: { value: 1.9 },
                uSpeedFactor: { value: STATE.ringSpeed }
            };
            particles = new THREE.Points(geo, new THREE.ShaderMaterial({
                uniforms: uniforms, vertexShader: SATURN_VS, fragmentShader: SATURN_FS,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            }));
            particles.rotation.z = 0.46; scene.add(particles);
        }

        function buildStars() {
            const count = 10000; const pos=[], s=[], c=[];
            for(let i=0; i<count; i++) {
                const r=600+Math.random()*2500, th=Math.random()*6.28, ph=Math.acos(2*Math.random()-1);
                pos.push(r*Math.sin(ph)*Math.cos(th), r*Math.cos(ph), r*Math.sin(ph)*Math.sin(th));
                s.push(Math.random()*2.0); c.push(1,1,1);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('s', new THREE.Float32BufferAttribute(s, 1));
            geo.setAttribute('c', new THREE.Float32BufferAttribute(c, 3));
            stars = new THREE.Points(geo, new THREE.ShaderMaterial({vertexShader: STAR_VS, fragmentShader: STAR_FS, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending}));
            scene.add(stars);
        }

        function buildPlanets() {
            planetGroup = new THREE.Group();
            
            // 1. 火星
            const marsGeo = new THREE.SphereGeometry(10, 64, 64);
            const marsMat = new THREE.ShaderMaterial({
                uniforms:{ },
                vertexShader: PLANET_VS, fragmentShader: MARS_FS
            });
            const mars = new THREE.Mesh(marsGeo, marsMat);
            mars.position.set(-300, 100, -450);
            planetGroup.add(mars);

            // 2. 地球
            const earthGeo = new THREE.SphereGeometry(14, 64, 64);
            earthUniforms = { uTime: { value: 0 } };
            const earthMat = new THREE.ShaderMaterial({
                uniforms: earthUniforms,
                vertexShader: PLANET_VS,
                fragmentShader: EARTH_FS
            });
            const earth = new THREE.Mesh(earthGeo, earthMat);
            earth.position.set(350, -80, -600);
            planetGroup.add(earth);

            scene.add(planetGroup);
        }

        // ================= UI 与控制 =================
        function togglePanel() {
            const panel = document.getElementById('control-panel');
            panel.classList.toggle('active');
        }

        function updateControlState() {
            const manualGroup = document.getElementById('manual-group');
            const sensGroup = document.getElementById('sens-group');
            const manualInd = document.getElementById('manual-ind');
            const statusText = document.getElementById('status-text');

            if (STATE.isGestureMode) {
                manualGroup.classList.add('disabled-control');
                sensGroup.classList.remove('disabled-control');
                manualInd.classList.remove('show-indicator');
                statusText.innerHTML = "手势控制: <span style='color:#c5a059'>扫描中</span>";
            } else {
                manualGroup.classList.remove('disabled-control');
                sensGroup.classList.add('disabled-control');
                manualInd.classList.add('show-indicator');
                statusText.innerHTML = "手动控制模式";
                STATE.manualScale = uniforms.uScale.value;
                STATE.manualRotX = uniforms.uRotationX.value;
                document.getElementById('inp-m-scale').value = STATE.manualScale;
                document.getElementById('val-m-scale').innerText = STATE.manualScale.toFixed(2);
                document.getElementById('inp-m-rot').value = STATE.manualRotX;
                document.getElementById('val-m-rot').innerText = STATE.manualRotX.toFixed(2);
            }
        }

        function setupControls() {
            const chk = document.getElementById('chk-gesture');
            chk.checked = false;
            chk.addEventListener('change', (e) => {
                STATE.isGestureMode = e.target.checked;
                updateControlState();
            });

            const inpMScale = document.getElementById('inp-m-scale');
            const valMScale = document.getElementById('val-m-scale');
            inpMScale.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                STATE.manualScale = v;
                valMScale.innerText = v.toFixed(2);
            });

            const inpMRot = document.getElementById('inp-m-rot');
            const valMRot = document.getElementById('val-m-rot');
            inpMRot.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                STATE.manualRotX = v;
                valMRot.innerText = v.toFixed(2);
            });

            const inpSpeed = document.getElementById('inp-speed');
            const valSpeed = document.getElementById('val-speed');
            inpSpeed.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                uniforms.uSpeedFactor.value = v;
                valSpeed.innerText = v.toFixed(2);
            });

            const binder = (id, objKey, scale=1, suffix='', isUniform=false) => {
                const el = document.getElementById(id);
                const disp = document.getElementById(id.replace('inp', 'val'));
                el.addEventListener('input', (e) => {
                    const v = parseFloat(e.target.value);
                    if(isUniform) uniforms[objKey].value = v;
                    else STATE[objKey] = v;
                    disp.innerText = (v * scale).toFixed(scale > 1 ? 0 : (id==='inp-bright'?1:2)) + suffix;
                    if(id === 'inp-lod') document.getElementById('ui-particles').innerText = (CONFIG.baseParticleCount * v / 1000).toFixed(0) + "k";
                });
            };

            binder('inp-bright', 'uBrightness', 1, '', true);
            binder('inp-lod', 'uLODLevel', 100, '%', true);
            binder('inp-sens', 'sensitivity', 1);
            
            document.getElementById('ui-particles').innerText = (CONFIG.baseParticleCount/1000).toFixed(0) + "k";
        }

        function gameLoop(now) {
            requestAnimationFrame(gameLoop);
            const dt = 0.016;
            
            if(uniforms) {
                uniforms.uTime.value += dt;
                if(earthUniforms) earthUniforms.uTime.value += dt;

                if (STATE.isGestureMode) {
                    if (isHandDetected) {
                        document.getElementById('status-text').innerHTML = "手势控制: <span style='color:#c5a059'>已锁定</span>";
                    } else {
                        document.getElementById('status-text').innerHTML = "手势控制: 扫描中...";
                    }
                } else {
                    targetScale = STATE.manualScale;
                    targetRotX = STATE.manualRotX;
                }
                uniforms.uScale.value += (targetScale - uniforms.uScale.value) * 0.1;
                uniforms.uRotationX.value += (targetRotX - uniforms.uRotationX.value) * 0.1;
            }

            if(stars) stars.rotation.y += dt * 0.05;
            if(planetGroup) planetGroup.rotation.y = Math.sin(now * 0.00005) * 0.1;

            renderer.render(scene, camera);
            
            if (now - stats.lastCheck > 1000) {
                document.getElementById('ui-fps').innerText = Math.round(stats.frameCount * 1000 / (now - stats.lastCheck));
                stats.frameCount = 0; stats.lastCheck = now;
            }
            stats.frameCount++;
        }

        // ================= AI =================
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        
        hands.onResults(results => {
            if (STATE.isGestureMode && results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const h = results.multiHandLandmarks[0];
                const d = Math.sqrt(Math.pow(h[4].x-h[8].x, 2) + Math.pow(h[4].y-h[8].y, 2));
                const normD = Math.max(0, Math.min(1, (d - 0.02) / 0.25));
                targetScale = 0.2 + normD * (3.0 * STATE.sensitivity);
                const y = h[9].y;
                const normY = Math.max(0, Math.min(1, (y - 0.1) / 0.8));
                targetRotX = -0.6 + normY * (1.6 * STATE.sensitivity);
            } else {
                isHandDetected = false;
            }
        });

        const videoEl = document.getElementsByClassName('input_video')[0];
        let skipCounter = 0;
        const cameraUtils = new Camera(videoEl, {
            onFrame: async () => {
                if (STATE.isGestureMode) {
                    if (skipCounter++ % 3 === 0) await hands.send({image: videoEl});
                }
            },
            width: 320, height: 240
        });
        cameraUtils.start();

        function toggleFullScreen() {
            if(!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if(document.exitFullscreen) document.exitFullscreen();
        }

        init();
    </script>
</body>
</html>